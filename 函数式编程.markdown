# 函数式编程
参考 https://www.ibm.com/developerworks/cn/java/j-understanding-functional-programming-1/index.html
## 定义
```
"函数式编程是一种编程范式。
它把计算当成是数学函数的求值，
从而避免改变状态和使用可变数据。
它是一种声明式的编程范式，
通过表达式和声明而不是语句来编程。"
```
## Functional programming:
https://en.wikipedia.org/wiki/Functional_programming

# 函数

| 术语     | 名称   | 解释                                 |
|:-------- | ------ |:------------------------------------ |
| argument | 参数   | 输入元素                             |
| value    | 值     | 输出元素                             |
| domain   | 定义域 | 输入元素的集合                       |
| codomain | 到达域 | 输出元素和其他附加元素的集合         |
| graph    | 图形   | 存在映射关系的输入和输出元素对的集合 |
| image    | 像     | 输出元素的集合                       |

# λ 演算
1. λ 演算中的函数都是匿名的
```
比如函数 sum(x, y) = x + y 可以写成 (x, y)|-> x + y
```
2. λ演算中的函数都只有一个输入。柯里化（currying）
```
 (x, y)|-> x + y 可以转换成 x |-> (y |-> x + y)
 右边的函数的返回值是另外一个函数。
```

# λ项
```
1. 一个变量 x 本身就是一个 λ 项。
2. 如果 M 是 λ 项，x 是一个变量，那么 (λx.M) 也是一个 λ 项。这样的 λ 项称为 λ 抽象（abstraction）。x 和 M 中间的点（.）用来分隔函数参数和内容。
3. 如果 M 和 N 都是 λ 项，那么 (MN) 也是一个 λ 项。这样的λ项称为应用（application）。
```

# 绑定变量
```
1. 对变量 x 来说，BV(x) = ∅。也就是说，一个单独的变量是自由的。
2. 对 λ 项 M 和变量 x 来说，BV(λx.M) = BV(M) ∪ { x }。也就是说，λ 抽象在 M 中已有的绑定变量的基础上，额外绑定了变量 x。
3. 对 λ 项 M 和λ项 N 来说，BV(MN) = BV(M) ∪ BV(N)。也就是说，λ 项的应用结果中的绑定变量的集合是各自 λ 项的绑定变量集合的并集。
```
# 自由变量
```
1. 对变量 x 来说，FV(x) = { x }。
2. 对 λ M 和变量 x 来说，FV(λx.M) = FV(M) − { x }。
3. 对 λ 项 M 和 λ 项 N 来说，FV(MN) = FV(M) ∪ FV(N)。
```
# 约简(reduction)
## α 变换（α-conversion）
```
目的是改变绑定变量的名称，避免名称冲突。
比如，我们可以通过 α 变换把 λx.x+1 转换成 λy.y+1。
如果两个λ项可以通过α变换来进行转换，则这两个 λ 项是 α 等价的。
```
```
 λ 抽象 λx.λx.x 可以 α 变换为 λx.λy.y 或 λy.λx.x，
 但是不能变换为 λy.λx.y
```
## β 约简（β-reduction）

## η 变换（η-conversion）

# 纯函数、副作用和引用透明性

# 函数式编程与并发编程

---

# 函数式编程范式的意义
# 函数类型与高阶函数
# 部分函数
# 柯里化
# 闭包
# 递归
# 记忆化

---

# Lambda 表达式
## 引入 Lambda 表达式的动机
## 函数式接口
## 目标类型
## 名称解析

# 流
## 顺序执行和 并行执行
## 相遇顺序
## Spliterator
## 有状态和无状态操作
## 流水线
```
源
中间操作
终结操作
```
---
# Vavr
# 元组
# 函数
```
组合
部分应用
柯里化方法
记忆化方法
```
# 值
```
Option
Either
Try
Lazy
```
# 数据结构
# 模式匹配
---
# 深入解析 Monad
# 范畴论
# Functor
# Monad
```
函数的副作用与组合方式
Monad 的定义
Writer Monad
Reader Monad
State Monad
```
